\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{ulem}
%\usepackage[brazil]{babel}  
\usepackage[utf8]{inputenc} 
   
\sloppy

\title{Maturidade no processo de desenvolvimento de software\\ Qualidade de código contínua }

\author{João Carlos Brasileiro Stefenon de Almeida\inst{1}}


\address{
	Universidade do Vale do Rio dos Sinos
 (UNISINOS)\\
 São Leopoldo -- RS -- Brazil 
\email{jcbrasileiro@hotmail.com}
}

\begin{document} 


\maketitle

  
\begin{resumo} 
Os métodos de desenvolvimento de software ágil têm se tornodo uma das principais abordagens no desenvolvimento de software, trazendo um grande impacto na engenharia de software, aumentando e alterando a percepção e o conceito de qualidade na códificação e na entrega de códigos.
Saber como utilizar conceitos e principios do design orientado a objeto (OOPD), CLEAN CODE - não excludente, produção de testes unitarios e/ou de integração - para aumentar a produtivida são extremamente importantes.
Este artigo corrobora com a aplicação desses conceitos e define uma melhor estratégia para alcançar um desenvolvimento mais eficaz e eficiente, produzindo códigos com alta qualidade e alto grau de manutenabilidade.
\end{resumo}


\begin{abstract}
The agile software development methods have become one of the main approaches in software development, bringing a great impact in software engineering, increasing and changing the perception and the concept of quality in coding and in delivering.
Knowing how to use object-oriented concepts and design principles (OOPD), CLEAN CODE - not excluding, producing unit tests and / or integration - to increase productivity are extremely important.
This article corroborates with the application of these concepts and defines the best strategy to achieve a more effective and efficient development, producing codes with high quality and high maintainability.
\end{abstract}


%\newpage 
%\tableofcontents
%\newpage

\part{INTRODUÇÃO}

%1º e 2º parágrafo: apresentação do tema dentro de um contexto.
 Uma das mudanças mais impactantes no processo de desenvolvimento de software das últimas décadas, foi a concepção e absorção das metodologias ágeis de software, seja SCRUM, Extreme Programming (XP), Test Driven Development (TDD), Lean Software Development, Kanban, etc, todas foram criadas a partir da filosofia AGILE \cite{MANISFESTOAGILE}, surgido a partir do esforço de várias pessoas que lidavam com o processo de software na década de 1990, com o objetivo de definir uma abordagem mais efetiva e eficiente para o desenvolvimento de software. Apesar dos conceitos já existirem a quase 20 anos, a importância e a implementação dessas ideias ainda são muito pouco exploradas no Brasil, segundo Coleman Parkes Research \cite{COLEMANPARKES_AGILE_2017}, durante uma pesquisa, envolvendo cerca de 1.770 executivos de tecnologia da informação em 21 países, incluindo 76 brasileiros, mostra que somente 6\% das empresas têm utilizado fortemente essa filosofia com o objetivo de "transformar toda a organização para abranger os princípios de agilidade".

 A partir dessa nova abordagem de gerenciar software, a importância da qualidade evoluiu e alcançou novos pontos de vistas, aumentando significativamente tanto na concepção, quanto no decorrer das outras fases, incluindo durante o desenvolvimento, e não mais apenas no final com um simples objetivo de execução do software. Um das grandes mudanças foi a inclusão e a utilização do conceito de \textbf{MPV}, sigla de \textit{Minimum Viable Product}, que significa Produto Mínimo Viável – conceito popularizado por Eric Ries \cite{ERICRIES_THELEAN} - trazendo a importância de entregar e assegurar o sistema de modo incremental, incluindo progressivamente funcionalidades importantes para o cliente, ou o negócio, ressaltando não apenas garantir um software útil, mas também visando minimizar a maleabilidade do ecossistema do negócio, seja as possibilidades de mudanças, tanto de prioridades de funções, técnicas ou mesmo do próprio objetivo fim. A adoção desses pequenos entregáveis, gerou e exigi um aumento na maturidade no desenvolvimento, criando a necessidade de gerar artefatos que evidenciassem e garantissem, desdo inicio, dois grandes aspectos: (i) Qualidade e (ii) a garantia que cada entregáveis operasse corretamente.

 Max Kanat-Alexander \cite{CODE_SIMPLICITY} resume sinteticamente uma interpretação da importância da qualidade do código/design: 

\begin{quote}
 \emph{"É mais importante reduzir o esforço de manutenção do que reduzir o esforço de implementação"}.
\end{quote} 


 Também reforça as consequências de ignorar o fato de existir um futuro, e cair no erro de criamos coisas que "apenas funcionam no presente", a partir disso menciona uma regra importante para a qualidade: 

\begin{quote}
 \emph{"O nível de qualidade do seu projeto deve ser proporcional ao tempo do futuro em que seu sistema continuará a ajudar as pessoas"}.
\end{quote} 


	Steve McConnell \cite{CODE_COMPLETE_2} deixa claro a ideia de qualidade de um código limpo, sendo uma parte principal, e não uma parte opicional no desenvolvimento, reforçando a importancia dos aspectos de um código bem feito (capacidade de extensão, código testavel, fácil comprensão, alta coesão, desacoplamento, entre outros).
	 

%3º parágrafo: delimitação do tema, apresentado através do problema de pesquisa do seu TCC.
%-- Código ruim e "Ice cream" problem
A partir dessas novas perpectivas e preocupações, e visando amadurecer a qualidade continua no processo de desenvolvimento foi identificado um grande problema na quantidade de esforço para manutenção de códigos com baixa extensibilidade e alto acoplamento, junto com uma alta taxa de “code smells”, termo criado por Kent Beck em conjuto de Martin Fowler \cite{MARTIN_FOWLER_REFACTORING}, e níveis muito baixos de qualidade de design/código.

%4º parágrafo: apresente possíveis respostas para o problema de pesquisa levantado, ou seja, as hipóteses.
%Aplicação das principios OO e CLEAN CODE.
%Segregação das testes unitarios e testes de integração.

%--REMOVE
\sout{Acreditando na importância da qualidade do código, o presente trabalho visou desenvolver, aplicar e avaliar uma estratégia para minimizar as adversidades na fase de um desenvolvimento eficiente, obter uma melhor produtividade através da codificação de códigos com alta manutenibilidade e alta confiabilidade, desacoplados e coeso, aplicando as ideias do CLEAN CODE, em conjunto com os mais difundidos princípios da programação orientada a objeto.}
%--REMOVE

Acreditando na importância da qualidade do código, o presente trabalho visou definir uma estratégia alçancar uma fase de desenvolvimento mais eficaz e eficiente através da aplicação dos conceitos e mais conhecidos principios de design orientado a objeto, CODE CODE e aplicação de TDD - incluindo teste de integração - produzindo códigos com alta qualidade e alta manutenabilidade.


%5º parágrafo: em poucas palavras, fale sobre o objetivo geral do trabalho e também dos específicos.
%Eles são ingredientes fundamentais para o trabalho.
A finalidade desse trabalho trabalho foi aplicar os conceitos do OODP (Object Oriented Design Principles), CLEAN CODE e “AGILE”, sendo assim, o objetivo geral foi analisar uma estratégia para produção de códigos com qualidade. A partir disso para alçancar o objetivo geral foram definidos os seguindos objetivos especificos: 
\begin{itemize}
	\item Identificar a correta aplicação dos conceitos de OOPD/CLEAN CODE.
	\item Identificar as melhores práticas para a produção de código eficiente.  
%--REMOVE
\sout{
Apontar uma pratica eficiente de códificação.
Identificar as melhores práticas para a produção de código eficiente. :
o resultado seria um quadro com a prática identificada, o seu propósito e um exemplo de como aplicar}
%--REMOVE
	\item Aplicar as melhores práticas identificadas.
%--REMOVE
\sout{ Definir métricas qualitativas e quantitativas para monitoramento da qualidade de código. ajustar um pouco para algo como: - Propor uma estratégia para aumentar a eficiência na codificação o que vai ter dentro da estratégia: recomendações (métricas para avaliar e ou monitorar o código)}
	\item Propor uma estratégia para aumentar a eficiência na codificação.
\end{itemize} 

%6º parágrafo: apresente a relevância do seu trabalho acadêmico, identificando a importância dele para a sociedade ou comunidade %científica. Isso é o que chamamos de justificativa.
O presente trabalho justifica-se por uma forte necessidade de ressaltar ao desenvolvedor, a responsabilidade direta pela produção do artefato final da fase de desenvolvimento (código-fonte)\cite{TR_CLEAN_CODE_IMPORTANCIA}, não apenas em relação ao presente, mas também quanto ao seu futuro, maximizar a rapidez de entendimento do código, ou sua possivel extensão, evidenciar a importância e a necessidade de conhecer, estudar e aplicar os conceitos de OOPD, e/ou do CLEAN CODE, que por sua vez, trouxe uma mudança de paradigma de como codificar software, como assegurar, minimizar e identificar impactos decorrentes de mudanças\cite{CODE_SIMPLICITY}.
Também visa, da perspectiva da empresa, evidenciando que diante um código com qualidade, código melhor estruturado, bem testado, fácil absorção e entendimento, a sua manutenção será mais eficiente e rápida, fazendo do desenvolvimento mais eficaz e eficiente, assim, gerando mais produtividade.

%7º parágrafo: descreva, em poucas palavras, qual metodologia foi utilizada. Foi pesquisa bibliográfica ou de campo?
%Você deve especificar o procedimento de forma concisa.
O plano de pesquisa desse trabalho utiliza uma abordagem mista utilizando de métricas quantitativas e qualitativas, de natureza aplicada, afim de determinar uma estratégia para maximizar a qualidade de código, explorando técnicas, conceitos e praticas. Utilizando do método de pesquisa estudo de caso, através de cenários, reais, baseados em cenarios, ou simulção do problema, para analisar os resultados objetivos a partir. 

%8º parágrafo: apresente a estrutura do trabalho, ou seja, como ele está dividido em capítulos. Lembre-se de falar, %resumidamente, sobre o que se trata cada capitulo.
O presente trabalho foi estruturado em 7 capítulos.
O capítulo 1 apresenta a introdução. 
O capítulo 2 apresenta a revisão bibliografia.
O capítulo 3 apresenta os trabalhos relacionados. 
O capítulo 4 apresenta a metodologia de Pesquisa utilizada. 
O capítulo 5,apresenta a avaliação da solução proposta.
O capítulo 6,apresenta os trabalhos futuros.
E, o capítulo 7, apresenta a conclusão deste trabalho



\part{REVISÃO BIBLIOGRAFICA} \label{sec:revisaobibliografica}

\section{\textit{Clean Code}} \label{sec:cleancode}

"Clean code" \cite{ROBERT_MARTIN_CLEAN_CODE} é um conceito subjetivo, que de modo muito generico, significa código bem feito, incluindo saber transformar um "código ruim" em um "código bom", ou o conhecimento da diferença entre ambos, assim como escrever um "código bom". Robert C. Martin \cite{ROBERT_MARTIN_CLEAN_CODE} debate os conceitos do que é "certo" e o que é "errado" na codificação. Destacando pontos impotantes para alcançar o nível de qualidade como principios, padrões, e boas práticas, passando por estudos de casos de diversos tipos e complexidades, uma base de conhecimento que descreve e explicar o racícinio usado durante a leitura, a escrita e durante a aplicação do "clean code", como a utilização de nomes significativos, escritas de funções pequenas e com objetivos claros, The Stepdown Rule \footnote{The Stepdown Rule \cite{ROBERT_MARTIN_CLEAN_CODE}, um código deve ser escrito de modo "TOPDOWN", aonde o programa fosse um conjunto des parágrafos "TO-DO", cada um descrevendo o nível atual de abstração e referenciando subseqüentemente outro parágrafos "TO-DO" no próximo nível de abstração abaixo.}, formatação de código, importancia de um sistema testavel \footnote{Um sistema que é testado de forma abrangente e passa todos os seus testes o tempo todo é um sistema testável. Essa é uma declaração óbvia, mas importante. Sistemas que não são testáveis
não são verificáveis. Provavelmente, um sistema que não pode ser verificado nunca deve ser implantado}, entre outros pontos. 

Também destaca o esforço necessario para absorver o conhecimento, e conhecer o "clean code" \cite{ROBERT_MARTIN_CLEAN_CODE}:

\begin{quotation}
\textit{"Aprender a escrever um código limpo é um trabalho árduo. Exige mais do que apenas o conhecimento de princípios e padrões. Você deve suar sobre ele. Você deve praticá-lo você mesmo, e assistir você falha. Você deve observar os outros praticando e falhar. Você deve vê-los tropeçar e siga seus passos. Você deve vê-los agonizantes sobre as decisões e ver o preço que pagam fazendo essas decisões do jeito errado." }
\end{quotation}

\section{\textit{Object-Oriented Design Principles (OODP)}} \label{sec:oopd}
 
 Os principios de design orientado a objeto, tem como objetivo ajudar os desenvolvedores a eliminar "design smell" \footnote{"Desing smell"\ \cite{ROBERT_MARTIN_AGILE_SW_DEV_PPP} é um sintoma, algo mensuravel, subjetivamente se não objetivamanete, que normalmente, é o resultado de uma ou mais violações aos principios.} e construir melhores soluções para o atual problema/"feature".

\subsection{\textit{S.O.L.I.D principles}} \label{sec:solid}

 Conceitos apresentendo iniciamente em 2002 \cite{ROBERT_MARTIN_AGILE_SW_DEV_PPP}, como parte do processo "agile design":
 
 \begin{quote}
\textit{" É a aplicação contínua de princípios, padrões e práticas para melhorar a estrutura e a legibilidade do software. É a dedicação de permanecer o design do sistema tão simples, limpa e expressiva quanto possivel a todo hora. "}
 \end{quote}

 Posteriormente, em 2004, estes cinco princípios tornou conhecido pelo acrônimo "SOLID", após Michael Feathers reorganizar as sequencia dos itens. 

\begin{itemize}
	\item \textbf{SRP} - Single responsibility principle
	\item \textbf{OCP} - Open closed principle
	\item \textbf{LSP} - Liskov substitution principle
	\item \textbf{ISP} - Interface segregation principle
	\item \textbf{DIP} - Dependency Inversion principle
\end{itemize}

\subsubsection{SRP - Single responsibility principle}
\begin{quote}
	\textit{"A classe deve ter apenas uma responsabilidade."}	
\end{quote}
\subsubsection{OCP - Open closed principle}
\begin{quote}
	\textit{"Entidades de software (classes, modulos, fuções..) devem estar abertas para extensão, mas fechadas para modificação."}	
\end{quote}
\subsubsection{LSP - Liskov substitution principle}
\begin{quote}
	\textit{"Subtipos \footnote{Também conhecidas como "Classes derivadas".} devem ser substituíveis por suas classes base."}\footnote{Barbara Liskov escreveu em seu primeiro artigo em 1988, \textit{"What is wanted here is something like the following substitution property: If for each object $ o_1 $ of type S there is an object $ o_2 $ of type T such that for allprograms Pdefined in terms of T, the behavior of P is unchanged when $ o_1 $ is substituted for $ o_2 $ then S is a subtype of T."} }	
\end{quote}
\subsubsection{ISP - Interface segregation principle}
\begin{quote}
	\textit{"Muitas interfaces específicas são melhores do que uma interface com propósito generico."}	
\end{quote}
\subsubsection{DIP - Dependency Inversion principle}
\begin{quote}
	\textit{A - Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações.}
	
	\textit{B -  Abstrações não devem depender de detalhes. Detalhes devem depender de abstrações.}	
\end{quote}

\subsection{\textit{General Responsibility Assignment Software Principles (GRASP)}} \label{sec:grasp}
[WIP]
\begin{itemize}
	\item Controller	
	\item Creator
	\item Indirection
	\item Information Expert
	\item High Cohesion
	\item Low Coupling
	\item Polymorphism
	\item Protected Variations
	\item Pure Fabrication
\end{itemize}
[WIP]

\subsection{\textit{Favor Composition over Inheritance.}} \label{sec:favor_composition}
\begin{quote}
\textit{"Uma relação "HAS-A" pode ser melhor do que "IS-A"."}\cite{HEADFIRST_DESIGN_PATTERN}
\end{quote}

Criar sistemas usando a composição permite muito mais flexibilidade, permite uma maior facilidade na implementação, permite que você altere o comportamento em tempo de execução, desde que o objeto que você está compondo implementa a interface de comportamento correta. 


\subsection{\textit{Law of Demeter principles}} \label{sec:law_of_demeter}
[WIP]
A lei de Demeter foi desenvolvida em 1988 por Karl Lieberherr e Ian Holland, da Northeastem Univerity, com uma idéia extremamente simples: organizar e reduzir dependências entre classes.

Na classe C, para todos os métodos M definidos em C, todos os objetos com o qual M se comunica deve ser:

    Argumento de M
    Um membro de C

Objetos criados por M, por métodos que M invoca ou objetos de escopo global na classe são considerados argumentos de M.

Esta lei tem dois propósitos primários:

    Simplificar modificações;
    Simplificar a complexidade da programação.


\subsection{\textit{Don't Repeat Yourself (DRY)}} \label{sec:dey}
[WIP]

O princípio DRY ("não se repita") busca reduzir a duplicação de código e os problemas de manutenção resultantes, mas quando é mal aplicado aumenta o acoplamento e atrapalha a leitura do código. Conheça a opinião de vários especialistas sobre o princípio, suas aplicações e armadilhas.

DRY é uma abreviação para o inglês Don't Repeat Yourself, "Não se Repita". É o primeiro princípio do desenvolvimento de software mencionado por Andy Hunt e Dave Thomas no clássico livro O Programador Pragmático: de aprendiz a mestre. O princípio declara que:
% https://www.infoq.com/br/news/2012/07/DRY-acoplamento-duplicacao

\begin{quote}
\textit{Cada parte do conhecimento deve ter uma representação única, não ambígua e definitva dentro do sistema.}
\end{quote}


\subsection{\textit{Keep it Simple, Stupid. (KISS)}} \label{sec:kiss}
[WIP]
O princípio KISS – de “Keep It Simple, Stupid” – tem como principio manter a simplicidade e descartar a complexidade, no contexto de desenvolvimento de software o "descartar a complexidade" seria algo como quebrar aquele script complexo em “n” partes simples e de resolução única, ou seja, cada parte se limitaria a resolver somente uma única tarefa do problema principal.


\section{\textsl{Test-driven development (TDD)}} \label{sec:tdd}
[WIP]
%Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.
%
%The process can be defined as such:
%\begin{enumerate}
%	\item Write a failing unit test
%	\item Make the unit test pass
%	\item Refactor
%\end{enumerate}
%  
%
%Repeat this process for every feature, as is necessary.

\part{Trabalhos Relacionados} \label{sec:trabalhosrelacionados}

Com o objetivo de entender e levantar os diversos problema de design e manutenabilidade de código, foram analisadas diversas inciativas e estudos relacionados que utilizam ou exploram os conceito e objetivam a qualidade de código referente a esse trabalho.
Com isso, os principais trabalhos analisados foram: (i) trabalho de \cite{TR_CLEAN_CODE_INTRODUCAO} que explora os conceitos do CLEAN CODE, explicar e apresenta com mais detalhes algumas técnicas a serem utilizadas.

 (ii) \cite{TR_CLEAN_CODE_IMPORTANCIA} enfatiza por meio de exemplos a importância da aplicação do
Código Limpo com a finalidade de se obter um sistema robusto com poucos erros e alta manutenibilidade. Destacando ainda o quanto um código ruim pode custar às empresas e diminuir drasticamente a produtividade dos desenvolvedores através de um pequeno experimento, por fim, analisa estatisticamente as vantagens do código limpo comparado a um código convencional, concluindo que a partir dos resultados observados, os mesmos, sugerem que as técnicas, quando aplicadas disciplinadamente, podem aumentar a produtividade dos desenvolvedores, visto que o índice de manutenibilidade, alegibilidade e o tempo de manutenção são melhores.
 
 (iii) \cite{TR_QC_TECHNICAL_DEBT} fala sobre a dívida técnica, se referir a qualquer projeto de sistema, arquitetura, desenvolvimento dentro da base de código, é uma solução de curto prazo para qualquer trabalho específico, que é aplicado antes da solução completa ou adequada para
qualquer trabalho, como dizendo que não é uma solução a longo prazo para qualquer trabalho específico. É uma espécie de solução que é encaminhado pelos não especialistas para o conclusão ou entrega do produto, mas é atraídos pelos especialistas que podem comprometer a qualidade do produto.

 (iv) \cite{TR_CLEAN_CODE_METRICA} um mapeamento entre um conjunto de métricas de código-fonte, com o objetivo de facilitar a detecção de trechos de código com potencial de melhorias, apresenta uma maneira de interpretar as métricas.

 (v) \cite{CODE_READABILITY_TESTING_STUDY} demonstra
como o teste de legibilidade do código melhora a capacidade dos programadores
para escrever código legível, e identificar correções. Apresenta uma comparação de tecnicas e conclui com resultados positivos, relatando que as técnicas valem seu tempo investido e articula como os testes podem alterar positivamente seus hábitos de programação.
 
 (vi) \cite{CODE_SMELLS_REFLECT_IMPORTANT_MAINTAINABILITY_ASPECTS} esse artigo apresenta uma importante analisa sobre "code smell", sendo apresentado um relatório sobre um estudo empírico que investiga a extensão que os "code smell" refletem e afetam a capacidade de manutenção.

\part{Metodologia de Pesquisa} \label{sec:metodologia_Pesquisa}
[WIP]

\part{Avaliação da solução proposta} \label{sec:avaliacao}
[WIP]

\part{Trabalhos futuros} \label{sec:trabalhos_futuros}
[WIP]

\part{Conclusão} \label{sec:conclusao}
[WIP]


\bibliographystyle{sbc}
\bibliography{TCC-UNISINOS-ADS}

\end{document}