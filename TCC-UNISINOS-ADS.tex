\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}  

     
\sloppy

\title{Maturidade no processo de desenvolvimento de software\\ Qualidade de código contínua }

\author{João Carlos  Brasileiro Stefenon de Almeida\inst{1}}


\address{
	Universidade do Vale do Rio dos Sinos
  (UNISINOS)\\
  São Leopoldo -- RS -- Brazil  
\email{jcbrasileiro@hotmail.com}
}

\begin{document} 


\maketitle

\begin{abstract}
[WIP]
\end{abstract}
     
\begin{resumo} 
[WIP]
\end{resumo}

%\newpage 
%\tableofcontents
%\newpage

\part{INTRODUÇÃO}

%1º e 2º parágrafo: apresentação do tema dentro de um contexto.
 Uma das mudanças mais impactantes no processo de desenvolvimento de software das últimas décadas, foi a concepção e absorção das metodologias ágeis de software, seja SCRUM, Extreme Programming (XP), Test Driven Development (TDD), Lean Software Development, Kanban, etc, todas foram criadas a partir da filosofia AGILE \cite{MANISFESTOAGILE}, surgido a partir do esforço de várias pessoas que lidavam com o processo de software na década de 1990, com o objetivo de definir uma abordagem mais efetiva e eficiente para o desenvolvimento de software. Apesar dos conceitos já existirem a quase 20 anos, a importância e a implementação dessas ideias ainda são muito pouco exploradas no Brasil, segundo Coleman Parkes Research \cite{COLEMANPARKES_AGILE_2017}, durante uma pesquisa, envolvendo cerca de 1.770 executivos de tecnologia da informação em 21 países, incluindo 76 brasileiros, mostra que somente 6\% das empresas têm utilizado fortemente essa filosofia com o objetivo de "transformar toda a organização para abranger os princípios de agilidade".

 A partir dessa nova abordagem de gerenciar software, a importância da qualidade evoluiu e alcançou novos pontos de vistas, aumentando significativamente tanto na concepção, quanto no decorrer das outras fases, incluindo durante o desenvolvimento, e não mais apenas no final com um simples objetivo de execução do software. Um das grandes mudanças foi a inclusão e a utilização do conceito de \textbf{MPV}, sigla de \textit{Minimum Viable Product}, que significa Produto Mínimo Viável – conceito popularizado por Eric Ries \cite{ERICRIES_THELEAN} - trazendo a importância de entregar e assegurar o sistema de modo incremental, incluindo progressivamente funcionalidades importantes para o cliente, ou o negócio, ressaltando não apenas garantir um software útil, mas também visando minimizar a maleabilidade do ecossistema do negócio, seja as possibilidades de mudanças, tanto de prioridades de funções, técnicas ou mesmo do próprio objetivo fim. A adoção desses pequenos entregáveis, gerou e exigi um aumento na maturidade no desenvolvimento, criando a necessidade de gerar artefatos que evidenciassem e garantissem, desdo inicio, dois grandes aspectos: (i) Qualidade e (ii) a garantia que cada entregáveis operasse corretamente.

 Max Kanat-Alexander \cite{CODE_SIMPLICITY} resume sinteticamente uma interpretação da importância da qualidade do código/design: 
 
 \emph{"É mais importante reduzir o esforço de manutenção do que reduzir o esforço de implementação"}.
 
 Também reforça as consequências de ignorar o fato de existir um futuro, e cair no erro de criamos coisas que "apenas funcionam no presente", a partir disso menciona uma regra importante para a qualidade: 
 
 \emph{"O nível de qualidade do seu projeto deve ser proporcional ao tempo do futuro em que seu sistema continuará a ajudar as pessoas"}.
	
	Steve McConnell \cite{CODE_COMPLETE_2} deixa claro a ideia de qualidade de um código limpo, não é uma parte opicional no desenvolvimento, reforçando a importancia dos aspectos (capacidade de extensão, código testavel, fácil comprensão, alta coesão, desacoplamento, entre outros).
	 

%3º parágrafo: delimitação do tema, apresentado através do problema de pesquisa do seu TCC.
%-- Código ruim e "Ice cream" problem
A partir dessas novas perpectivas e preocupações, e visando amadurecer a qualidade continua no processo de desenvolvimento foi identificado um grande problema na quantidade de esforço para manutenção de códigos com baixa extensibilidade e alto acoplamento, junto com uma alta taxa de “code smells”, termo criado por Kent Beck em conjuto de Martin Fowler \cite{MARTIN_FOWLER_REFACTORING}, e níveis muito baixos de qualidade de design/código.

%4º parágrafo: apresente possíveis respostas para o problema de pesquisa levantado, ou seja, as hipóteses.
%Aplicação das principios OO e CLEAN CODE.
%Segregação das testes unitarios e testes de integração.
Acreditando na importância da qualidade do código, o presente trabalho visou desenvolver, aplicar e avaliar uma estratégia para minimizar as adversidades na fase de um desenvolvimento eficiente, obter uma melhor produtividade através da codificação de códigos com alta manutenibilidade e alta confiabilidade, desacoplados e coeso, aplicando as ideias do CLEAN CODE, em conjunto com os mais difundidos princípios da programação orientada a objeto.

%5º parágrafo: em poucas palavras, fale sobre o objetivo geral do trabalho e também dos específicos.
%Eles são ingredientes fundamentais para o trabalho.
A finalidade desse trabalho trabalho foi aplicar os conceitos do OODP (Object Oriented Design Principles), CLEAN CODE e “AGILE”, sendo assim, o objetivo geral foi analisar uma estratégia para produção de códigos com qualidade. A partir disso para alçancar o objetivo geral foram definidos os seguindos objetivos especificos: 
\begin{itemize}
	\item Identificar a correta aplicação dos conceitos de OOPD/CLEAN CODE.
	\item Apontar uma pratica eficiente de códificação.
	\item Definir métricas qualitativas e quantitativas para monitoramento da qualidade de código.
\end{itemize} 

%6º parágrafo: apresente a relevância do seu trabalho acadêmico, identificando a importância dele para a sociedade ou comunidade %científica. Isso é o que chamamos de justificativa.
O presente trabalho justifica-se por uma forte necessidade de ressaltar ao desenvolvedor, a responsabilidade direta pela produção do artefato final da fase de desenvolvimento (código-fonte), não apenas em relação ao presente, mas também quanto ao seu futuro, maximizar a rapidez de entendimento do código, ou sua possivel extensão, evidenciar a importância e a necessidade de conhecer, estudar e aplicar os conceitos de OOPD, e/ou do CLEAN CODE, que por sua vez, trouxe uma mudança de paradigma de como codificar software, como assegurar, minimizar e identificar impactos decorrentes de mudanças.
Também visa, da perspectiva da empresa, evidenciando que diante um código com qualidade, código melhor estruturado, bem testado, fácil absorção e entendimento, a sua manutenção será mais eficiente e rápida, fazendo do desenvolvimento mais eficaz e eficiente, assim, gerando mais produtividade.

%7º parágrafo: descreva, em poucas palavras, qual metodologia foi utilizada. Foi pesquisa bibliográfica ou de campo?
%Você deve especificar o procedimento de forma concisa.
O plano de pesquisa desse trabalho utiliza uma abordagem mista utilizando de métricas quantitativas e qualitativas, de natureza aplicada, afim de determinar uma estratégia para maximizar a qualidade de código, explorando técnicas, conceitos e praticas. Utilizando do método de pesquisa estudo de caso, através de cenários, reais, baseados em cenarios, ou simulção do problema, para analisar os resultados objetivos a partir. 

%8º parágrafo: apresente a estrutura do trabalho, ou seja, como ele está dividido em capítulos. Lembre-se de falar, %resumidamente, sobre o que se trata cada capitulo.
O presente trabalho foi estruturado em 7 capítulos.
O capítulo 2 apresenta os trabalhos relacionados. 
O capítulo 3 apresenta a revisão bibliografia.
O capítulo 4 apresenta a Metodologia de Pesquisa utilizada. 
O capítulo 5,apresenta a avaliação da solução proposta.
O capítulo 6,apresenta os trabalhos futuros.
E, o capítulo 7, apresenta a conclusão deste trabalho

\part{Trabalhos Relacionados} \label{sec:trabalhosrelacionados}

Com o objetivo de entender e levantar os diversos problema de design e manutenabilidade de código, foram analisadas diversas inciativas e estudos relacionados que utilizam ou exploram os conceito e objetivam a qualidade de código referente a esse trabalho.
Com isso, os principais trabalhos analisados foram: (i) trabalho de \cite{TR_CLEAN_CODE_INTRODUCAO} que explora os conceitos do CLEAN CODE, explicar e apresenta com mais detalhes algumas técnicas a serem utilizadas.

 (ii) \cite{TR_CLEAN_CODE_IMPORTANCIA} enfatiza por meio de exemplos a importância da aplicação do
Código Limpo com a finalidade de se obter um sistema robusto com poucos erros e alta manutenibilidade. Destacando ainda o quanto um código ruim pode custar às empresas e diminuir drasticamente a produtividade dos desenvolvedores através de um pequeno experimento, por fim, analisa estatisticamente as vantagens do código limpo comparado a um código convencional, concluindo que a partir dos resultados observados, os mesmos, sugerem que as técnicas, quando aplicadas disciplinadamente, podem aumentar a produtividade dos desenvolvedores, visto que o índice de manutenibilidade, alegibilidade e o tempo de manutenção são melhores.
 
 () \cite{TR_QC_TECHNICAL_DEBT} fala sobre a dívida técnica, se referir a qualquer projeto de sistema, arquitetura, desenvolvimento dentro da base de código, é uma solução de curto prazo para qualquer trabalho específico, que é aplicado antes da solução completa ou adequada para
qualquer trabalho, como dizendo que não é uma solução a longo prazo para qualquer trabalho específico. É uma espécie de solução que é encaminhado pelos não especialistas para o conclusão ou entrega do produto, mas é atraídos pelos especialistas que podem comprometer a qualidade do produto.

  (iii) \cite{TR_CLEAN_CODE_METRICA} um mapeamento entre um conjunto de métricas de código-fonte, com o objetivo de facilitar a detecção de trechos de código com potencial de melhorias, apresenta uma maneira de interpretar as métricas.

  (iv) \cite{CODE_READABILITY_TESTING_STUDY} demonstra
como o teste de legibilidade do código melhora a capacidade dos programadores
para escrever código legível, e identificar correções. Apresenta uma comparação de tecnicas e conclui com resultados positivos, relatando que as técnicas valem seu tempo investido e articula como os testes podem alterar positivamente seus hábitos de programação.
  
  (v) \cite{CODE_SMELLS_REFLECT_IMPORTANT_MAINTAINABILITY_ASPECTS} esse artigo apresenta uma importante analisa sobre "code smell", sendo apresentado um relatório sobre um estudo empírico que investiga a extensão que os "code smell" refletem e afetam a capacidade de manutenção.

\part{REVISÃO BIBLIOGRAFICA} \label{sec:revisaobibliografica}

\section{\textit{Clean Code}} \label{sec:cleancode}
[WIP]

Learning to write clean code is hard work. It requires more than just the knowledge of
principles and patterns. You must sweat over it. You must practice it yourself, and watch
yourself fail. You must watch others practice it and fail. You must see them stumble and
retrace their steps. You must see them agonize over decisions and see the price they pay for
making those decisions the wrong way.

\section{\textit{Object-Oriented Design Principles (OODP)}} \label{sec:oopd}
[WIP]

\subsection{\textit{S.O.L.I.D principles}} \label{sec:solid}
\begin{itemize}
	\item Single responsibility principle
	\item Open closed principle
	\item Liskov substitution principle
	\item Interface segregation principle
	\item Dependency Inversion principle
\end{itemize}
[WIP]

\subsection{\textit{General Responsibility Assignment Software Principles (GRASP)}} \label{sec:grasp}
[WIP]
\begin{itemize}
	\item Controller	
	\item Creator
	\item Indirection
	\item Information Expert
	\item High Cohesion
	\item Low Coupling
	\item Polymorphism
	\item Protected Variations
	\item Pure Fabrication
\end{itemize}
[WIP]

\subsection{\textit{Favor Composition over Inheritance.}} \label{sec:favor_composition}
[WIP]

\subsection{\textit{Law of Demeter principles}} \label{sec:law_of_demeter}
[WIP]

\subsection{\textit{Don't Repeat Yourself (DRY)}} \label{sec:dey}
[WIP]

\subsection{\textit{Keep it Simple, Stupid. (KISS)}} \label{sec:kiss}
[WIP]

\section{\textsl{Test-driven development (TDD)}} \label{sec:tdd}
[WIP]
Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated test case that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally refactors the new code to acceptable standards.

The process can be defined as such:
\begin{enumerate}
	\item Write a failing unit test
	\item Make the unit test pass
	\item Refactor
\end{enumerate}
    

Repeat this process for every feature, as is necessary.

\part{Conclusão} \label{sec:conclusao}
[WIP]

\part{Trabalhos futuros} \label{sec:trabalhos_futuros}
[WIP]

\bibliographystyle{sbc}
\bibliography{TCC-UNISINOS-ADS}

\end{document}
